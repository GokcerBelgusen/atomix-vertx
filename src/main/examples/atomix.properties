#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License
#

# This is the address to which to bind the local server. This address may or may
# not be present in the cluster.seed list below. If the address is present in the
# seed list, this node will start as a full member of the cluster. If the address is
# not present in the seed list, this node will join the cluster defined by the seeds.
replica.address=XXX.XXX.XXX.XXX:5749

# This is the transport to use to communicate between replicas. The transport must
# be the same class on all replicas.
replica.transport=io.atomix.catalyst.transport.NettyTransport

# These are standard TCP configuration options.
replica.transport.connectTimeout=5000
replica.transport.sendBufferSize=-1
replica.transport.receiveBufferSize=-1
replica.transport.reuseAddress=true
replica.transport.tcpKeepAlive=true
replica.transport.tcpNoDelay=false
replica.transport.acceptBacklog=1024

# This property indicates whether SSL should be enabled for the transport.
replica.transport.ssl.enabled=false

# This is a list of members of the cluster to which to connect. If the local member
# is joining a cluster, its address will not be present in the seed list. If the
# local member is forming a new cluster, its address will be present in the seed
# list. The first time the cluster is started, n seed nodes should be started where
# n is the size of the Raft quorum.
cluster.seed.1=XXX.XXX.XXX.XXX:5749
cluster.seed.2=XXX.XXX.XXX.XXX:5749
cluster.seed.3=XXX.XXX.XXX.XXX:5749

# This property indicates the desired size of the quorum. The quorum consists
# of some set of nodes that participate in the Raft consensus algorithm. Writes to
# the cluster are synchronously replicated to a majority of the members in the quorum.
# Atomix guarantees that at least cluster.quorumHint replicas will be in the quorum
# so long as cluster.quorumHint members have joined the cluster.
# The default value of -1 indicates that the cluster.seed list represents the desired
# quorum size. This is typically a good default since clusters are normally started with
# the desired number of nodes as seed nodes.
cluster.quorumHint=-1

# This property indicates the desired number of backup replicas for each active member
# of the quorum. When a quorum member is partitioned or crashes, Atomix will attempt to
# replace that member with a backup replica. The process of replacing nodes can be shortened
# by replicating to more backup nodes. Members of the quorum replicate to backup nodes
# asynchronously, so the number of backups does not significantly impact latency.
cluster.backupCount=0

# These properties are Raft-specific configurations that define the intervals at which
# Raft servers and clients communicate with one another. The electionTimeout and heartbeatInterval
# control the frequency of communication between servers. The sessionTimeout controls the
# frequency of keep-alive requests from clients. Note that decreasing the sessionTimeout can
# result in e.g. a lock held by a crashed node being released sooner, but decreasing the sessionTimeout
# also implies more overhead for frequent keep-aive requests.
cluster.electionTimeout=1000
cluster.heartbeatInterval=500
cluster.sessionTimeout=10000

# These properties dictate how Raft logs are stored for this replica. By default, Atomix stores
# logs on disk. Alternatively, the MAPPED and MEMORY storage.level can be used for greater efficiency
# at the potential expense of more memory consumption and loss of safety. In order for writes to be
# lost in a cluster of replicas using storage.level=MEMORY, a majority of the cluster would have
# to crash and lose their logs from memory.
storage.level=DISK
storage.directory=logs
storage.maxSegmentSize=33554432
storage.maxEntriesPerSegment=1048576

# These properties dictate the behavior of log compaction in Atomix. Log compaction includes a
# combination of incremental rewrites of the log and storage of snapshots of the system's state.
# Snapshots inherit the storage.level, so snapshots stored with storage.level=MEMORY will not
# be stored on disk but can be replicated to other servers.
storage.compaction.maxSnapshotSize=33554432
storage.compaction.retainSnapshots=false
storage.compaction.threads=2
storage.compaction.minor=60000
storage.compaction.major=600000
storage.compaction.threshold=0.5